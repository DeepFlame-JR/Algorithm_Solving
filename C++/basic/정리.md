# 메모리와 포인터
- 메모리: 16진수의 주소를 가짐 (1 바이트)
    - 변수를 선언하면 메모리에 저장 (int의 경우 4바이트를 예약)
    - 주소: 점유 중인 메모리 중 가장 앞의 메모리의 주소
- 포인터: 메모리의 주소를 담는 타입
    - 동적 할당, 데이터를 복사하지 않음
    ```cpp
    int a = 4;
    int *b = &a;  // 같은 변수로 정의해야함 (b == &a)
    ```
- 역참조 연산자
    ```cpp
    string a = "test";
    string *b = &a;
    cout << b << '\n';  // 0x0001001
    cout << *b << '\n';  // "test"
    ```


# 재귀 함수
- 자기 자신을 계속해서 불러오는 함수 (재참조하는 함수)
- 큰 문제를 부분 문제로 나눠서 풀 때 활용

#### 주의 사항
- 종료 조건 > 로직 > 다시 호출의 순서
    - 종료 조건이 없다면 무한히 호출됨
- 매개 변수가 계속 바껴야함. (사이클이 존재하면 안 된다)
- Overlapping Problem이 존재 > 시간이 많이 걸림

#### 예시

```cpp
int fact(int n){
    if(n == 1 | n == 0) return 0;
    return n * fact(n-1)
}

int fibo(int n){
    if(n == 1 | n == 0) return n;
    return fibo(n-1) + fibo(n-2);
}
```

# 비트마스킹

### 기초
- AND, OR
    - &: 모두 1이여야지 > 1
    - |: 1이 하나라도 있다 > 1
- SHIFT (logical shift)
    - << n: 왼쪽으로 n 칸 이동하면서 우측을 0으로 채움 (X2^n)
        - 111 << 1 : 1110
    - \>> n: 오른쪽으로 n 칸 이동함 (/2^n)
        - 111 >> 1 : 11
- 기타 연산자
    - ^: XOR 연산 (다르면 1, 같으면 0)
        - 1001^1000 = 0001
    - ~: 1의 보수 연산자 (비트를 반전)
        - ~1001 = 0110
        - ~value = -(value+1)
            - ~4 = -5


### 활용
- idx번째 비트 끄기: S &= ~(1<<idx)
    - idx=2 > 11111 & 11011 = 11101
- idx번째 비트 켜기: S |= ~(1<<idx)
    - idx=2 > 10001 | 00100 = 10101
- idx번째 비트 XOR 연산: S ^= (1<<idx) 
- 최하위 켜져있는 비트 찾기: idx = (S&-S)
    - S=10100 > -S=01011+1 > -S=01100 > S&-S=00100
    - 뒤에 0들이 모두 1이되는데 여기에 1을 더하면 얘네가 다 0이 되면서 최하위 1의 자리만 1이되면서 그 자리만 둘 다 1인 곳으로 변경
- 크기가 n인 집합의 모든 비트 켜기: (1<<n)-1
    - n=3 > 1000-1 > 111
- idx번째 비트가 켜져 있는지 확인하기: if(S&(1<<idx))
    - S=10100, idx=2 > 10100&100 > 00100 => true
    - S=10100, idx=1 > 10100&10 > 00000 => false

### 비트 마스킹
- 불리언 배열을 "하나의 숫자"로 만들어서 탐색, 수정 등의 작업을 하는 것
    - {0,1,0,1} 으로 만들지 않고, 0101이라는 하나의 수 5를 통해 배열같은 역할을 함
- 비트 마스킹을 이용한 경우의 수
    ```cpp
    int main(){
        string a[n] = {"사과", "딸기", "포도", "배"};
        for(int i = 0 ; i (1<<n); i++){
            string ret = "";
            for(int j = 0 ; j < n ; j++){
                // j번째 비트가 켜져있는가?
                if(i & (1 << j)) ret += (a[j] + " ");
            }
            cout << ret << '\n';
        }
        return 0;
    }
    ```
- n이 31이 최대라는 한계가 있음 
    - long long으로도 가능하지만 시간초과가 난다

### 그리디